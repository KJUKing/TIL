# 캐시

  클라이언트 캐시가 만료돼서 새로 데이터를 받아야하는 상황에 만약 클라이언트가 보유한 캐시와 서버가 가진 데이터가 똑같다면
  캐시를 재사용 할 수 있지만 클라이언트와 데이터간의 데이터가 일치하다는 사실을 확인할 수 있는 방법이 필요

  검증 헤더 추가
   * Last-Modified: 2020년 1월 1일 01:00:00
     
      -데이터 최종 수정일과 대조시켜 일치할시 로컬 캐시 사용
     
      -서버에서는 HTTP/1.1 304 Not Modified라는 수정되지않았다는 정보의 헤더를 전송(body는 보내지않는다)      
      -if-modified-since: 2020년 1월 1일 01:00:00 등으로 수정되었는지 물어보는 조건식도 붙힐수있다        
                =데이터 미변경시 304 Not Modified, 데이터 변경시 200 OK
     
      -단점 1. 1초 미만 단위로 캐시조정 불가 2. 날짜 기반의 로직 사용

   * ETag(Entity Tag)
      -캐시용 데이터에 임의의 고유한 버전 이름을 달 수 있음
     
      -ETag가 같으면 유지 다르면 다시받으면 된다    
      -캐시 제어 로직을 서버에서 완전히 관리함      
      -클라이언트는 단순히 이 값을 서버에 제공함(클라이언트는 캐시 매커니즘을 모름)    

## 1. 캐시 제어 헤더

   * Cache-Control
      -max-age : 캐시 유효 시간, 초 단위
      -no_cache : 데이터는 캐시해도 되지만, 항상 원(Origin) 서버에 검증하고 사용함
      -no-store : 데이터에 민감한 정보가 있으므로 저장하면 안됨(메모리에서 사용후 최대한 빨리 삭제)

   * Pragma, Expires - 하위호환이므로 별로 사용하지않음

## 2. 프록시 캐시
  
  외국의 origin서버에서 국내의 클라이언트까지 직통으로 연결하면 전송속도가 오래걸리므로
  적절한 장소에 중계 서버를 두는 것이 프록시 캐시서버다
  국내 클라이언트에서 미리 받아놓은 프록시 캐시서버에서 첫번째때 데이터를 받으면 두번째때부터 한결 빠르게 전송받을 수 있다.   
  
  프록시 캐시 서버 - public 캐시 / 클라이언트 캐시 - private 캐시
  
   * Cache-Control : 캐시 지시어  
      - public : 응답이 public 캐시에 저장되어도 됨    
      - private : 응답이 해당 사용자만을 위한 것, private 캐시에 저장해야함(디폴트 값)    
      - s-maxage : 프록시 캐시에만 적용되는 max-age    
      - age: 60(HTTP 헤더) : 오리진 서버에서 응답 후 프록시 캐시 내에 머문 시간(초)    

## 3. 캐시 무효화

  확실한 캐시 무효화 응답 : 이 페이지는 캐시가 되면 안된다 라고 명시적으로 선언    
  no-cache, no-store, must-revalidate    
  
  * must-revalidate : 캐시 만료후 최초 조회시 원 서버에서 검증해야함        
                          원 서버 접근 실패시 반드시 오류가 발생해야함 - 504(Gateway Timeout)    
  * Pragma: no-cache(하위호환)    
    
